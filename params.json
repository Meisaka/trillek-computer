{"name":"Trillek Computer","tagline":"Trillek Virtual Computer specifications","body":"Trillek Virtual Computer Specs\r\n=====================================\r\nVersion 0.4h\r\n\r\n**ADVICE** : In this documents there some technical stuff that could looks hard\r\nor complex to understand for not hardware guys.\r\nSome of these stuff there is only to give natural limitations of what can do \r\nand can't do the computer. If your only interest is programing the computer, \r\nyou should check the instruction set of a CPU and the specs of the devices to\r\nunderstand how program the computer and use the devices at assembly or C \r\nprograming level.\r\n\r\n**NOTATION** : Byte is a 8 bit value. Word is a 16 bit value and DWord is a 32 \r\nbit value.\r\n\r\nSUMMARY\r\n------\r\n\r\n - 32 bit data bus, but allow transfers of 16 and 8 bit.\r\n - 24 bit address space (0x000000-0xFFFFFF).\r\n - Little endian architecture.\r\n - 32KiB ROM chip at address 0x100000-0x107FFF\r\n - Initial 128KiB RAM at address 0x000000- 0x01FFFF\r\n - RAM expandable with modules of 128KiB to a total of 1 MiB of RAM \r\n   (0x000000-0x0FFFFF)\r\n - CPUs are connected by a CPU board (actually TR3200 and DCPU-16N) to the \r\n   mother board. Only one CPU can be connected to the computer at same time \r\n   (not multi-processor setups)\r\n - CPU Clock speed could be 1Mhz , 500 Khz, 200 Khz and 100Khz (actually we \r\n   work with 100Khz, but we expect to allow higher speeds). CPU clock speed in KHz \r\n   can be read at address 0x11E050 (I/O port 0xE050 on DCPU-16N)\r\n - Devices uses a fixed clock of 100Khz (thinking to change it to 50 KHz) if \r\n   they need to do periodic or sync stuff.\r\n - Devices are [memory mapped](http://en.wikipedia.org/wiki/Memory-mapped_I/O).\r\n   So dcpu's **HWI** is replaced by writing/reading to addresses where the \r\n   device is listening. **HWN** and **HWQ** is replaced by reading addresses.\r\n - Addresses used by devices are over 0x110000 to avoid address clashes with \r\n   the RAM/ROM.\r\n - Addresses 0x110000 to 0x112000 are reserved to Devices Enumeration and \r\n   Communication.\r\n - At address 0x11XX00, were **XX** is the device slot number (to a total \r\n   of 32 -> 0x20), there is mapped the **Enumeration And Control registers** of \r\n   device **XX**, that consists : \r\n   Device Type, Device SubType, Device ID, Device Vendor ID, CMD, A, B, C, \r\n   D, E hardware registers. \r\n - Devices could do **DMA** operations at will, but ONLY one device could do \r\n   that at same time, and can only transfer 4 bytes every Device Clock (like \r\n   if the DMA operates in the falling clock flank and the CPU operated in the\r\n   rising clock flank.)\r\n - Usually the devices exposes his own ram and&or uses commands. The only \r\n   exception is the most basic graphics device that uses computer RAM as buffer.\r\n - The computer can be expanded to a total 32 devices, not counting integrated \r\n   devices on motherboard. This can be archived by plugin the device boards in \r\n   the expansion bus. Some devices will require a external module attached to \r\n   the computer, like floppy drives, graphics cards, joysticks, weapons, etc...\r\n - Integrated devices on motherboard:\r\n     - Programmable Interval Timer (**PIT**) aka *Clock* device.\r\n     - Real Time Clock (**RTC**), that gives the date and time in game world \r\n       when is polled (not have alarm).\r\n     - Random Number Generator (**RNG**), that generates a 32 bit random number\r\n       every time that is polled (at implementation level, a simple call to \r\n       rand_r)\r\n     - Beeper or *buzzer* device (**Beeper**). Simply generates a squared wave \r\n       sound at desired frequency.\r\n     - 256 bytes of NVRAM (Not Volatile RAM). Usefull to store basic configration \r\n       used in boot time.\r\n     - 256 bytes reserved for CPU board HW registers from 0x11FF00 to 0x11FFFF\r\n\r\n\r\nHOW WORKS\r\n---------\r\n![Computer Architecture Diagram](./img/computer.png \"Diagram\")\r\n\r\nAs can you see, the computer uses a 24 bit Address Bus and 32 bit Data bus. RAM\r\nand ROM are directly attached to these buses, as any device in the computer\r\nthat is controllable by software. Also there is the integrated devices.\r\n\r\n### Interrupts\r\n\r\nTo avoid clashes with interrupt petitions, we daisy chain the interrupt signals\r\n*INT* and *IACQ* . So when two devices try to generate a interrupt at same time\r\n, the device more near to the CPU (with lowest slot number), have preference. \r\nThe **PIT** and **Keyboard controller** devices can generate interrupts, so we \r\nput it between the expandable devices and the CPU having more preference that \r\nany expansion device. Plus the **PIT** have more preference as is more near to \r\nthe CPU that the Keyboard Controller.\r\n\r\n**NOTE FOR USERS**: In other words, you only need to worry about the interrupt \r\nmessage in your **Interrupt Service Routine** (ISR). This stuff is to put some \r\nlimitations to the computer and add some details at implementation of it.\r\n\r\n**NOTE FOR IMPLEMENTATION**: This means that when you need to \"executes\" the \r\nhardware devices, you only need to loop the device array in order and check if \r\ndevice **x** send a Interrupt. If it happens, allow it to send the message to \r\nthe CPU, and just ignore the Interrupt petitions for the rest of the loop.\r\n\r\n### Hardware Enumeration\r\n\r\nDevices maps 0x11XX00 address block, were XX is the slot were is plugged. \r\nIn these address block that we call **Enumeration And Control registers**, there\r\n is a few registers :\r\n\r\n - Present flag (Read byte): At offset 0,there is a byte that always read 0xFF \r\n   if a device is plugged in these slot.\r\n - Device Type register (Read byte): At offset 1, there is a byte that gives \r\n   information about the device type (see Device Type list section).\r\n - Device SubType register (Read byte): At offset 2, there is a byte that gives \r\n   information about the device subtype (see Device Type list section).\r\n - Device ID register (Read byte) : At offset 3, there is a byte that gives the\r\n   Device ID. \r\n - Device Vendor ID register (Read dword) : At offset 4, there is dword that \r\n   gives the Vendor/Builder ID of the device (see know Device Vendor list section). \r\n - CMD register (Write word) : At offset 8, there is a d that writing to it, \r\n   sends a command to the device. The command list is dependent of the device,\r\n   and is showed in the device specs.\r\n - A, B, C, D, E registers (Read/Write word every one) : Begin at offset 10, \r\n   there is five word registers that are used to send values with the commands \r\n   and receive status/error or other stuff from the devices.\r\n\r\n![Device Enumeration And Control Header](./img/DevConfigHeader.png \"DevHeader\")\r\n \r\nTo know how many devices are plugged to the computer, you only need to read the \r\nfirst byte of the 32 addresses and count one more for every byte being 0xFF.\r\nThe tuple {Device Vendor ID, Device ID} defines a unique device. This information \r\ncan be used to allow the software know what device is plugged and how should \r\nuse it.\r\nDevices that have the same {Device Type ID, Device SubType ID} are expect that \r\nshare some minimal compatibility. To archive this, should share a minimal list \r\nof commands with the same expected behavior.\r\n\r\n**NOTE FOR USERS**: This is nearly the same stuff that does the original \r\nNotch's DCPU-16, but being memory mapped instead of being special magic \r\ninstructions. Each device have his own set registers. The device at slot 0 have\r\nthis registers at 0x110000, and his A register is at 0x11000A; device 8 have this \r\nregisters at 0x110800, and his BuildID register is at 0x110804; etc...\r\n\r\n#### Device Types and SubTypes values\r\n\r\nHere is a list of Device Types. Each entry could contain a sublist of actually know subtypes.\r\n\r\n - 0x00 : Unclassified device\r\n - 0x01 : Audio devices (Sound Cards)\r\n - 0x02 : Communications device\r\n     - 0xFF : Serial Console\r\n - 0x03 : HID (Human Interface Device)  \r\n     - 0x01 : Western/Latin Keyboard\r\n - 0x04 : Expansion bus device\r\n - 0x06 : Image/Video Input device\r\n - 0x07 : Printer (2D and 3D) device\r\n - 0x08 : Mass Storage device (Floppy drives, Microdrives, Hard disks, Tape \r\n   recorders)\r\n     - 0x01 : Floppy drive\r\n - 0x09 : Network device\r\n - 0x0A : Co-Processors\r\n - 0x0E : Graphics Devices (Graphics card)\r\n     - 0x01 : TGA compatible\r\n - 0x0F : HoloGraphics Devices\r\n - 0x10 : Ship Sensors (DRADIS, Air, Hull integrity, etc...)\r\n - 0x11 : Power Management Systems (control of Generators)\r\n - 0x12 : Hydraulic/Pneumatic Actuators (control of doors, air-locks, landing \r\n   gears)\r\n - 0x13 : Electric Engines (control of wheels and steering)\r\n - 0x1A : Defensive Systems (control of shields)\r\n - 0x1B : Offensive Systems (control of weapons)\r\n - 0x1C : Sub-FTL Navigational and Engine Systems (control of thrusters and \r\n   engines)\r\n - 0x1D : FTL Navigational Systems (control of warp engines)\r\n - 0xFF : Unassigned class\r\n\r\n#### Know Vendor values\r\n\r\n- 0x00000000 -> Unknown builder (reserved value)\r\n- 0x048BAD15 -> RocoCorp.\r\n- 0x1C6C8B36 -> Nya Elektriska\r\n- 0x1EB37E91 -> Mackapar Media\r\n- 0x21544948 -> Harold Innovation Technologies (Harold I.T.)\r\n- 0x494E5645 -> Investronics\r\n- 0xA87C900E -> KaiComm\r\n\r\n### PIT (PROGRAMMABLE INTERVAL TIMER)\r\n\r\nThe PIT consists in two 32 bit timers as can you find in any modern \r\nmicro-controller. Allow to do time measurements and generate periodic \r\ninterrupts for system clock and tasks switchers. Have the highest priority when\r\nneeds to signal a interrupt.\r\n\r\n**NOTE FOR USERS**: Could look a bit more hard that the Noth's DCPU-16 Timer \r\ndevice, but gives more freedom and control. Plus is more easy to \r\nunderstand and use that the IBM PC timer. Using the highest interrupt priority \r\nmeans that will be the first Interrupt to be attended by the CPU when \r\nsimultaneous interrupts happens.\r\n\r\n**NOTE FOR VM IMPLEMENTATION**: Uses two vars per timer. One stores the Reload \r\nvalue and the other count downs every timer clock tick. The times generated are\r\nin Virtual Computer time, so if you run the Virtual Computer at 200% speed, the\r\nmeasured times should be the half.\r\n\r\n### RTC (Real Time Clock)\r\n\r\nIs a basic device that gives the actual game time and date. Not have alarm, so \r\nis necessary doing a polling every 12 or 24 hours to keep a software clock in \r\nsync with game time. Gives time information in dd-mm-yyyy hh:mm:ss format (see specs)\r\n\r\n### RNG (Random Number Generator)\r\nIs a basic device that writing to it, sets the RNG seed, and reading from it, \r\ngets a 32 bit random number. Simply reading a dword from 0x11E040 gets a 32 bit \r\nrandom number. Writing to the same address, setups the random seed. (see specs)\r\n\r\n### Beeper\r\nSimple basic Beeper with similar functionality to the IBM PC speaker or \r\nZX Spectrum beeper. It have less power as can't allow do PWM to generate basic\r\ncrude PCM sound, but it makes a lot more simple to use and understand.\r\n\r\n**NOTE FOR VM IMPLEMENTATION**: Try to use a Band-Limited Sound Synthesis lib \r\nto generate square wave sound, but a crude Fourier synthesis could do the trick.\r\n\r\n### NVRAM\r\nThe computer motherboard includes a small 256 bytes NVRAM powered by a litium battery.\r\nThis small not volatile RAM are mapped in 0x11F000 to 0x11F0FF, and can be used \r\nfor boot configuration stuff.\r\n\r\n### Devices with DMA (Direct Memory Access)\r\nDMA operations by the hardware devices are allowed, but only one DMA operation \r\ncould be happening at same time at a rate of 4 byte for each device clock. To \r\navoid that two or more devices try to do a DMA operation, there is a BUSY BUS \r\nsignal. DMA operations happens in the opposite flank that the CPU clock, so \r\ndon't interfere and not need contention hardware.\r\n\r\n**NOTE FOR VM IMPLEMENTATION**: By practical reasons, this will translated in a\r\nflag in the Virtual Computer to indicate if a device will being doing DMA, as \r\ncan't be two devices doing a DMA at same time. \r\n\r\n\r\nDOCUMENTS\r\n---------\r\n\r\n### CPUs\r\n\r\n- [TR3200 CPU](./cpu/TR3200.md)\r\n- [DCPU-16N CPU](./cpu/DCPU-16N.txt)\r\n\r\n### Embed Devices\r\n\r\n- [Programmable Interval Timer](./embed/Timers.md) (aka Timer or Clock)\r\n- [RTC](./embed/RTC.md)\r\n- [RNG](./embed/RNG.md)\r\n- [Beeper](./embed/Beeper.md)\r\n\r\n### Devices\r\n\r\n- [Generic Keyboard](./devices/Keyboard.md)\r\n- [Text Generator Adapter](./devices/TGA.md) (TGA)\r\n- [Color Display Adapter](./devices/CDA.md) (CDA)\r\n- [5.25\" Floppy Drive](./devices/floppy_drive.md) (M5FDD)\r\n- [Debug Serial Console](./devices/SerialConsole.md.md)\r\n\r\n### MISC\r\n\r\n- [Computer Architecture Diagram](./img/computer.png)\r\n- [Memory Model](./img/memory_map.png)\r\n- [Calling Conventions](./cpu/calling_convention.md)\r\n\r\nADVICE\r\n------\r\n\r\nTrillek MS2.5, is not using the latests specs. Please use the latest version \r\nfrom trillek-vcomputer-module.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}